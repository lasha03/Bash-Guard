"""
Vulnerability model for representing security issues.
"""

from dataclasses import dataclass
from enum import Enum, auto
from pathlib import Path
from typing import Optional, List, Dict, Any, Tuple


class SeverityLevel(Enum):
    """Severity levels for vulnerabilities."""
    LOW = auto()
    MEDIUM = auto()
    HIGH = auto()
    CRITICAL = auto()


class VulnerabilityType(Enum):
    """Types of vulnerabilities that can be detected."""
    COMMAND_INJECTION = auto()
    ENVIRONMENT = auto()
    PATH_TRAVERSAL = auto()
    VARIABLE_EXPANSION = auto()
    PARAMETER_EXPANSION = auto()
    PRIVILEGE = auto()
    SHELLCHECK = auto()
    OTHER = auto()

class Description(Enum):
    """Desciprtions for the found vulnerabilities."""
    MISSING_PATH = (
        "PATH variable is missing. For security, it's recommended to explicitly declare a safe PATH at the beginning of the script."
    )

    PARAMETER_EXPANSION_0 = (
        "Be careful when expanding parameter 0. View possible attacks ..."
    )

@dataclass
class Vulnerability:
    """
    Represents a security vulnerability found in a Bash script.
    """
    
    # Basic information
    vulnerability_type: VulnerabilityType
    severity: SeverityLevel
    description: str
    
    # Location information
    file_path: Path
    pos: Tuple[int, int] = (-1, -1)
    line_number: int = -1
    column: Optional[int] = None
    line_content: Optional[str] = None
    
    # Additional information
    code_snippet: Optional[str] = None
    recommendation: Optional[str] = None
    cve_id: Optional[str] = None
    references: Optional[List[str]] = None
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Perform post-initialization tasks."""
        if self.pos[0] != -1:
            try:
                covered_symbols = 0
                with open(self.file_path, 'r') as f:
                    lines = f.readlines()
                    line_number = 0
                    for line in lines:
                        line_number += 1
                        if covered_symbols + len(line) > self.pos[0]:
                            self.line_number = line_number
                            break
                        covered_symbols += len(line)
            except:
                pass 

        if self.line_content is None and self.file_path.exists():
            try:
                with open(self.file_path, 'r') as f:
                    lines = f.readlines()
                    if 0 <= self.line_number - 1 < len(lines):
                        self.line_content = lines[self.line_number - 1].rstrip()
            except:
                pass 